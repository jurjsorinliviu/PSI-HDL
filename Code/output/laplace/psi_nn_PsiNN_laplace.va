// Verilog-A Neural Network Module
// Auto-generated by Psi-HDL Framework
// Model Type: PsiNN_laplace
// Input Dimension: 2
// Output Dimension: 1
// Total Layers: 4
//
// This module implements a neural network discovered by Psi-NN
// as an analog behavioral model suitable for SPICE simulation.

`include "constants.vams"
`include "disciplines.vams"


module psi_nn_PsiNN_laplace(in0, in1, out0, vdd, vss);
    // Input ports (voltage nodes)
    input in0;
    input in1;

    // Output ports (voltage nodes)
    output out0;

    // Power supply nodes
    input vdd, vss;
    
    // Declare port types as electrical
    electrical in0;
    electrical in1;
    electrical out0;
    electrical vdd, vss;


    // Neural network parameters (weights and biases)
    // These can be overridden during instantiation

    // Layer 0: layer1 (psi_plus_minus)
    parameter real fc1_2_w[0:19][0:0] = 0.0;
    parameter real fc1_4_w[0:19][0:0] = 0.0;

    // Layer 1: layer2 (psi_symmetric)
    parameter real fc2_2_w[0:19][0:19] = 0.0;
    parameter real fc2_4_w[0:19][0:19] = 0.0;

    // Layer 2: layer3 (psi_combination)
    parameter real fc3_2_w[0:39][0:19] = 0.0;

    // Layer 3: output (output)
    parameter real output_w[0:0][0:39] = 0.0;
    parameter real output_b[0:0] = 0.0;


    // Internal variables for layer computations
    real input_vec[0:1];
    real output_vec[0:0];
    real layer_out[0:39];
    real temp_sum;
    integer i, j;


    analog begin
        // Read input voltages and normalize
        input_vec[0] = V(in0) / 1.0;
        input_vec[1] = V(in1) / 1.0;

        // Forward propagation through network

        // Layer 1: +/- structure with tanh activation
        // u1_3 = tanh(fc1_2(x) + fc1_4(y))
        // u1_4 = tanh(fc1_2(x) - fc1_4(y))
        
        temp_sum = fc1_2_w[0][0] * input_vec[0] + fc1_2_b[0];
        
        layer_out[0] = tanh(temp_sum + fc1_4_w[0][0] * input_vec[1]);
        layer_out[1] = tanh(temp_sum - fc1_4_w[0][0] * input_vec[1]);
        
        // Layer 2: Symmetric interchange
        // u2_3 = tanh(fc2_2(u1_3) + fc2_4(u1_4))
        // u2_4 = tanh(fc2_4(u1_3) + fc2_2(u1_4))
        
        real u1_3, u1_4;
        u1_3 = layer_out[0];
        u1_4 = layer_out[1];
        
        layer_out[0] = tanh(fc2_2_w[0][0] * u1_3 + fc2_2_b[0] + 
                           fc2_4_w[0][0] * u1_4 + fc2_4_b[0]);
        layer_out[1] = tanh(fc2_4_w[0][0] * u1_3 + fc2_4_b[0] + 
                           fc2_2_w[0][0] * u1_4 + fc2_2_b[0]);
        
        // Layer 3: Addition
        // u3_2 = tanh(fc3_2(u2_3) + fc3_2(u2_4))
        real u2_3, u2_4;
        u2_3 = layer_out[0];
        u2_4 = layer_out[1];
        
        layer_out[0] = tanh(fc3_2_w[0][0] * (u2_3 + u2_4) + fc3_2_b[0]);
        
        // Layer 4: Output (linear with bias for even function)
        output_vec[0] = output_w[0][0] * layer_out[0] + output_b[0];

        // Write output voltages
        V(out0) <+ output_vec[0] * 1.0;
    end


endmodule
